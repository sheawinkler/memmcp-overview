<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Context Lattice | Private memory fabric for AI agents</title>
  <link rel="stylesheet" href="styles.css?v=20260217c" />
</head>
<body class="home">
  <main class="container">
    <header class="topbar">
      <a class="brand" href="index.html">
        <span class="brand-mark" aria-hidden="true"></span>
        <span class="brand-label">Context Lattice</span>
      </a>
      <nav class="nav" aria-label="Primary">
        <a class="active" href="index.html">Home</a>
        <a href="updates.html">Updates</a>
        <a href="installation.html">Installation</a>
        <a href="troubleshooting.html">Troubleshooting</a>
        <a href="contact.html">Contact</a>
        <a href="v1/">v1</a>
      </nav>
    </header>

    <section class="hero">
      <span class="badge">Private memory layer for agents</span>
      <h1>Fix context drift before it burns your token budget.</h1>
      <p class="sub">
        Context Lattice (memMCP) gives agents reusable memory with HTTP MCP, federated retrieval,
        durable fanout, and storage guardrails so quality and costs remain stable under load.
      </p>
      <ul class="chips">
        <li>HTTP-only MCP</li>
        <li>Federated retrieval</li>
        <li>Durable outbox fanout</li>
        <li>Learning rerank schema</li>
        <li>Letta RAG support</li>
        <li>Retention controls</li>
      </ul>
      <div class="cta-row">
        <a class="cta primary" href="mailto:pilot@contextlattice.io?subject=Context%20Lattice%20Pilot">Book a pilot</a>
        <a class="cta secondary" href="updates.html">Read updates</a>
      </div>
      <div class="hero-art" aria-hidden="true">
        <span class="orb orb-a"></span>
        <span class="orb orb-b"></span>
        <span class="orb orb-c"></span>
        <span class="grid-sheen"></span>
      </div>
    </section>

    <div class="lattice-ribbon" aria-hidden="true">
      <span class="ribbon-wave ribbon-wave-a"></span>
      <span class="ribbon-wave ribbon-wave-b"></span>
      <span class="ribbon-dots"></span>
    </div>

    <section class="section">
      <div class="grid">
        <article class="card">
          <div class="kicker">What it solves</div>
          <h3>Memory quality + cost control</h3>
          <p>Replace repetitive long-context stuffing with reusable memory retrieval and sink durability.</p>
        </article>
        <article class="card">
          <div class="kicker">How it runs</div>
          <h3>Local first, enterprise path ready</h3>
          <p>Run on your machine now, then graduate to managed deployment with policy and access controls.</p>
        </article>
        <article class="card">
          <div class="kicker">Latest platform step</div>
          <h3>Self-protecting orchestrator</h3>
          <p>Fanout coalescer, Letta admission control, and retention workers reduce backlog and storage pressure.</p>
        </article>
      </div>
    </section>

    <section class="section">
      <article class="card">
        <div class="kicker">Learning retrieval</div>
        <h3>Orchestrator gets better at memory recall over time</h3>
        <p class="spotlight">
          The orchestrator uses a learning schema from feedback signals to rerank results and improve
          retrieval precision over time. This is reinforced by RAG through Letta archival memory,
          alongside Qdrant, Mongo raw, MindsDB, and memory-bank fallback.
        </p>
        <p class="muted-note">Read the detailed rollout notes on the <a href="updates.html">Updates page</a>.</p>
      </article>
    </section>

    <section class="section">
      <div class="kicker">How it all works together</div>
      <article class="card">
        <h3>Unified write + retrieval loop through the orchestrator</h3>
        <p>
          Every write enters through the orchestrator, which records durable raw data, fans out to specialized stores,
          and continuously protects queue and storage health. Every search comes back through the same orchestrator so
          results can be fused, reranked, and improved over time from feedback.
        </p>
        <ul class="chips">
          <li>Write intake</li>
          <li>Outbox fanout</li>
          <li>Federated search</li>
          <li>Learning rerank</li>
          <li>Retention + guardrails</li>
        </ul>
      </article>
    </section>

    <section class="section">
      <div class="kicker">Service Map</div>
      <h2>Data Flow</h2>
      <div class="grid flow-grid">
        <article class="card flow-card">
          <div class="kicker">Receive + Store</div>
          <h3>Write distribution spine</h3>
          <svg class="flow-svg" viewBox="0 0 640 500" role="img" aria-label="Orchestrator write spine through validation, raw write, and fanout with parallel sink distribution">
            <defs>
              <marker id="w-arrow-main" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
                <path d="M0,0 L10,5 L0,10 z" fill="#0f5b57"></path>
              </marker>
              <marker id="w-arrow-branch" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
                <path d="M0,0 L10,5 L0,10 z" fill="#b3643c"></path>
              </marker>
            </defs>
            <text class="section-label" x="24" y="98">Ingress</text>
            <text class="section-label" x="242" y="98">Orchestrator spine methods</text>
            <text class="section-label" x="460" y="150">Parallel sink distribution</text>

            <rect class="flow-node input-node" x="24" y="22" rx="10" ry="10" width="176" height="46"></rect>
            <text x="38" y="50">Client write request</text>
            <line class="flow-line method-link" x1="200" y1="45" x2="220" y2="45" marker-end="url(#w-arrow-main)"></line>

            <rect class="flow-node orchestrator-node" x="220" y="18" rx="12" ry="12" width="198" height="54"></rect>
            <text class="flow-node-title" x="319" y="50" text-anchor="middle">Orchestrator</text>
            <line class="flow-line spine-line" x1="319" y1="72" x2="319" y2="336" marker-end="url(#w-arrow-main)"></line>

            <rect class="flow-node method-node" x="240" y="102" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="128" text-anchor="middle">Validation</text>

            <rect class="flow-node method-node" x="240" y="164" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="190" text-anchor="middle">Raw write</text>
            <line class="flow-line branch-line" x1="398" y1="186" x2="460" y2="186" marker-end="url(#w-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="166" rx="9" ry="9" width="156" height="40"></rect>
            <text x="474" y="190">Mongo raw ledger</text>

            <rect class="flow-node method-node" x="240" y="226" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="252" text-anchor="middle">Fanout</text>
            <line class="flow-line branch-line" x1="398" y1="248" x2="438" y2="248" marker-end="url(#w-arrow-branch)"></line>
            <line class="flow-line bus-line" x1="438" y1="248" x2="438" y2="430"></line>

            <line class="flow-line bus-branch" x1="438" y1="273" x2="460" y2="273" marker-end="url(#w-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="256" rx="9" ry="9" width="156" height="34"></rect>
            <text x="474" y="278">Memory Bank MCP</text>

            <line class="flow-line bus-branch" x1="438" y1="319" x2="460" y2="319" marker-end="url(#w-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="302" rx="9" ry="9" width="156" height="34"></rect>
            <text x="474" y="324">Qdrant</text>

            <line class="flow-line bus-branch" x1="438" y1="365" x2="460" y2="365" marker-end="url(#w-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="348" rx="9" ry="9" width="156" height="34"></rect>
            <text x="474" y="370">MindsDB</text>

            <line class="flow-line bus-branch" x1="438" y1="411" x2="460" y2="411" marker-end="url(#w-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="394" rx="9" ry="9" width="156" height="34"></rect>
            <text x="474" y="416">Letta</text>
          </svg>
          <p class="muted-note flow-caption">Single orchestrator spine, explicit method stages, and parallel fanout branches to all write sinks.</p>
        </article>
        <article class="card flow-card">
          <div class="kicker">Read + Return</div>
          <h3>Retrieval spine</h3>
          <svg class="flow-svg" viewBox="0 0 640 500" role="img" aria-label="Orchestrator retrieval spine with parallel federated sources, reranking, and response return">
            <defs>
              <marker id="r-arrow-main" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
                <path d="M0,0 L10,5 L0,10 z" fill="#0f5b57"></path>
              </marker>
              <marker id="r-arrow-branch" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
                <path d="M0,0 L10,5 L0,10 z" fill="#b3643c"></path>
              </marker>
            </defs>
            <text class="section-label" x="24" y="110">Federated sources (parallel)</text>
            <text class="section-label" x="242" y="98">Orchestrator spine methods</text>
            <text class="section-label" x="460" y="224">Response + learning loop</text>

            <rect class="flow-node input-node" x="24" y="22" rx="10" ry="10" width="176" height="46"></rect>
            <text x="38" y="50">Client search request</text>
            <line class="flow-line method-link" x1="200" y1="45" x2="220" y2="45" marker-end="url(#r-arrow-main)"></line>

            <rect class="flow-node orchestrator-node" x="220" y="18" rx="12" ry="12" width="198" height="54"></rect>
            <text class="flow-node-title" x="319" y="50" text-anchor="middle">Orchestrator</text>
            <line class="flow-line spine-line" x1="319" y1="72" x2="319" y2="338" marker-end="url(#r-arrow-main)"></line>

            <rect class="flow-node method-node" x="240" y="102" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="128" text-anchor="middle">Federate</text>

            <rect class="flow-node method-node" x="240" y="164" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="190" text-anchor="middle">Rerank</text>

            <rect class="flow-node method-node" x="240" y="226" rx="10" ry="10" width="158" height="44"></rect>
            <text x="319" y="252" text-anchor="middle">Return</text>

            <line class="flow-line bus-line" x1="204" y1="136" x2="204" y2="430"></line>
            <line class="flow-line bus-branch" x1="204" y1="124" x2="240" y2="124" marker-end="url(#r-arrow-branch)"></line>

            <rect class="flow-node sink-node" x="24" y="120" rx="9" ry="9" width="160" height="34"></rect>
            <text x="38" y="142">Memory Bank MCP</text>
            <line class="flow-line bus-branch" x1="184" y1="137" x2="204" y2="137"></line>

            <rect class="flow-node sink-node" x="24" y="166" rx="9" ry="9" width="160" height="34"></rect>
            <text x="38" y="188">Qdrant</text>
            <line class="flow-line bus-branch" x1="184" y1="183" x2="204" y2="183"></line>

            <rect class="flow-node sink-node" x="24" y="212" rx="9" ry="9" width="160" height="34"></rect>
            <text x="38" y="234">Mongo raw</text>
            <line class="flow-line bus-branch" x1="184" y1="229" x2="204" y2="229"></line>

            <rect class="flow-node sink-node" x="24" y="258" rx="9" ry="9" width="160" height="34"></rect>
            <text x="38" y="280">MindsDB</text>
            <line class="flow-line bus-branch" x1="184" y1="275" x2="204" y2="275"></line>

            <rect class="flow-node sink-node" x="24" y="304" rx="9" ry="9" width="160" height="34"></rect>
            <text x="38" y="326">Letta</text>
            <line class="flow-line bus-branch" x1="184" y1="321" x2="204" y2="321"></line>

            <line class="flow-line branch-line" x1="398" y1="248" x2="460" y2="248" marker-end="url(#r-arrow-branch)"></line>
            <rect class="flow-node sink-node" x="460" y="228" rx="9" ry="9" width="156" height="40"></rect>
            <text x="474" y="252">Ranked response</text>

            <rect class="flow-node input-node" x="460" y="304" rx="9" ry="9" width="156" height="46"></rect>
            <text x="474" y="331">Feedback to learning schema</text>
            <path class="flow-line feedback-line" d="M460 327 C414 327 410 214 398 186" marker-end="url(#r-arrow-branch)"></path>
          </svg>
          <p class="muted-note flow-caption">Federated sources converge to the orchestrator spine, then reranked results return with learning feedback.</p>
        </article>
      </div>
      <div class="grid component-grid">
        <article class="card component-card">
          <h3>Orchestrator</h3>
          <p><strong>Benefit:</strong> one control plane for writes, retrieval, and policy.</p>
          <p><strong>Why:</strong> central coordination is what allows multi-source ranking and learning to compound.</p>
        </article>
        <article class="card component-card">
          <h3>Memory Bank MCP</h3>
          <p><strong>Benefit:</strong> canonical project/file context store.</p>
          <p><strong>Why:</strong> keeps user-facing memory deterministic and compatible with MCP-native clients.</p>
        </article>
        <article class="card component-card">
          <h3>Qdrant</h3>
          <p><strong>Benefit:</strong> high-speed semantic recall.</p>
          <p><strong>Why:</strong> vector retrieval gives broad relevance quickly before deeper reranking.</p>
        </article>
        <article class="card component-card">
          <h3>Mongo Raw</h3>
          <p><strong>Benefit:</strong> durable source-of-truth write ledger.</p>
          <p><strong>Why:</strong> protects recoverability and enables repair/rehydrate workflows.</p>
        </article>
        <article class="card component-card">
          <h3>MindsDB</h3>
          <p><strong>Benefit:</strong> SQL-friendly analytics and structured querying.</p>
          <p><strong>Why:</strong> complements semantic search with tabular and operational insight paths.</p>
        </article>
        <article class="card component-card">
          <h3>Letta (RAG memory)</h3>
          <p><strong>Benefit:</strong> long-horizon archival context for agent reasoning.</p>
          <p><strong>Why:</strong> deep memory context improves difficult recall beyond nearest-neighbor hits.</p>
        </article>
        <article class="card component-card">
          <h3>Fanout Outbox</h3>
          <p><strong>Benefit:</strong> resilient async delivery with retries, coalescing, and admission control.</p>
          <p><strong>Why:</strong> prevents sink instability from breaking ingestion reliability.</p>
        </article>
        <article class="card component-card">
          <h3>Retention + Telemetry</h3>
          <p><strong>Benefit:</strong> bounded storage growth and observable runtime behavior.</p>
          <p><strong>Why:</strong> operational stability is required for learning retrieval to stay trustworthy.</p>
        </article>
      </div>
    </section>

    <section class="section">
      <article class="card">
        <div class="kicker">Why this boosts learning retrieval impact</div>
        <h3>Learning is strongest when memory is both rich and reliable</h3>
        <p>
          The orchestrator's learning schema can only improve ranking if retrieval sources stay healthy, durable,
          and synchronized. This architecture makes that possible: Qdrant provides fast candidates, Letta supplies
          deeper RAG context, Mongo guarantees recovery, MindsDB adds structured recall, and guardrails keep the
          full loop from collapsing under pressure.
        </p>
      </article>
    </section>

    <section class="section">
      <div class="kicker">Flexible Launch</div>
      <h2>Deployment Modes</h2>
      <div class="grid mode-grid">
        <article class="card mode-card">
          <h3>Lite mode</h3>
          <p>Best for local development and constrained laptops where stable memory services matter more than deep analytics.</p>
          <ul class="spec-list">
            <li><strong>Includes:</strong> Orchestrator, Memory Bank MCP, Mongo raw, Qdrant, outbox fanout, retention workers</li>
            <li><strong>Compute:</strong> 2-4 vCPU recommended</li>
            <li><strong>Memory:</strong> 4-8 GB RAM baseline</li>
            <li><strong>Storage:</strong> 25-60 GB SSD depending on write volume</li>
          </ul>
        </article>
        <article class="card mode-card">
          <h3>Full mode</h3>
          <p>Best for high-write workloads and richer retrieval where learning loops use every sink, including RAG through Letta.</p>
          <ul class="spec-list">
            <li><strong>Includes:</strong> Lite mode plus MindsDB analytics, Letta archival memory, observability stack, and full rehydrate tooling</li>
            <li><strong>Compute:</strong> 6-8 vCPU recommended</li>
            <li><strong>Memory:</strong> 16-24 GB RAM baseline</li>
            <li><strong>Storage:</strong> 120-200 GB SSD depending on retention policy</li>
          </ul>
        </article>
      </div>
    </section>

    <footer class="footer">
      <span>Context Lattice public overview</span>
      <span>Private by default. MCP-compatible by design.</span>
    </footer>
  </main>
</body>
</html>
